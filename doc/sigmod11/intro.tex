\section{Introduction}
\label{s:intro}

Theft of sensitive private data is a significant
problem~\cite{prc:breaches}.  Database management systems (DBMSs) are
an especially appealing target for attackers, because they often
contain large amounts of private information.  When individual
users or enterprises store their sensitive data in a DBMS today, they
must trust that the server hardware and software are uncompromisable,
that the data center itself is physically protected, and assume that
the system and database administrators (DBAs) 
%who maintain the DBMS software 
are trustworthy.  Otherwise, an adversary who gains access to any of
these avenues of attack can compromise the entire database, as has
been documented in a number of published reports of data
thefts~\cite{prc:breaches} (and presumably there are more
compromises that have not been publicized).

These stringent security requirements are also at odds with
cost-saving measures such as the consolidation of DBMSs belonging to
different business units into a common enterprise-wide IT
infrastructure, moving databases into a public cloud, or outsourcing
DBA tasks.  In fact, ``lack of trust'' is an oft-quoted primary
concern about moving data in database systems to more cost-effective
cloud infrastructures.  Moreover, thanks to high-profile thefts of
social security identifiers, credit card numbers, and other personal
information from various online databases, these concerns are
increasingly being reflected in the law as well: for instance, recent
legislation requires that all databases containing personal data about
Massachusetts residents be encrypted~\cite{Masslaw}.

% A significant barrier to deploying database systems in the cloud is
% the perceived lack of privacy, which in turn reduces the degree of
% trust users are willing to place in such deployments. If clients were to
% encrypt all the data stored in the cloud database, and if the data
% were decrypted only on client-controlled machines, then privacy
% concerns would largely be eliminated. Similarly, even in so-called
% private clouds inside enterprises, users often desire the ability to
% store data and run queries in data centers without trusting the
% database and system administrators with the content.

This paper presents {\em CryptDB}, a practical relational DBMS that
provides provable privacy guarantees without having to trust the DBMS
server or the DBAs who maintain and tune the DBMS\@.  In CryptDB,
unmodified DBMS servers store {\em all} data in an encrypted format,
and execute SQL queries over encrypted data without having access
to the decryption keys.  CryptDB works by intercepting and rewriting
all SQL queries in a {\em frontend} to make them execute on encrypted data,
by encrypting and decrypting all data, as well as changing some query
operators, while preserving the overall semantics of the query.
The frontend has access to the encryption key for the
entire database.  By not giving the DBMS server access to the
decryption key, CryptDB greatly reduces trust requirements for a
DBMS server.  For example, CryptDB can alleviate privacy concerns when
outsourcing databases to a cloud computing
environment~\cite{xeround-blog}, such as Amazon's AWS, Microsoft's SQL
Azure, or Google's AppEngine, or when outsourcing the work of DBAs.
CryptDB can also prevent privacy breaches due to curious
administrators~\cite{chen:gmail-snooping} or compromised DBMS servers.
%even if the database is not outsourced.

% \hb{May not be necessary for SIGMOD.}
% SQL provides a good trade-off between generality and efficiency in cloud storage.
% On the one hand, SQL is widely used and useful to the many applications that
% already store their data in SQL databases, and use SQL queries to efficiently
% process their data.  On the other hand, SQL provides a structured data
% representation and a declarative query language that is much easier to reason
% about and to process efficiently over encrypted data than a general-purpose
% computation.


% \hb{Less related work here.}
% While early proposals attempted to enable SQL processing over encrypted
% data~\cite{sqlOverEncryption}, their privacy mechanisms were mostly heuristic,
% required a significant rewrite of the DBMS design, relied on considerable
% client-side processing, and did not support certain SQL queries. More recent
% literature~\cite{Dawn-Song-Search-2000, Chang04privacypreserving,
% queriesEncryptionBoneh,
% amanatidis-boldyreva-o'neill, Yang-privacy-preserving-queries,
% encrypt-for-secure-outsource, private-query-multi-user-for-searchable} has
% developed cryptographic tools for searching keywords on encrypted data and has
% proposed using these tools to process SQL queries on encrypted data. Although such
% work is a good first cut at the problem, it does not provide a
% comprehensive systems solution: they do not support many basic SQL queries (and
% mostly only support equality comparisons), some of them require significant
% client-side query processing, change the internal processing of a DBMS, and many
% of these schemes are too inefficient (requiring users either to build and maintain
% indexes or to perform sequential scans for every selection).

There are three significant challenges in designing and implementing a
DBMS that operates on encrypted data.  The first lies in supporting a
wide range of SQL queries on encrypted data.  Unlike a simple
encrypted data store, a DBMS must perform {\em computations} on
encrypted data to execute SQL queries.  For example, an SQL query may
ask for the average salary of employees, for the names of employees
whose salary is greater than \$60,000, or for the list of employees
that share an office with more than two colleagues.  Simply encrypting
each row in the database with a single key would not allow a DBMS
server to execute such SQL queries without access to the decryption
key.

The second challenge is to carefully define ``privacy'' for an
untrusted DBMS, as well as come up with a system design that
provably achieves that definition.  On the one hand, even if all of
the data stored on a DBMS server were encrypted, the server must be
able to perform certain operations on the rows, such as aggregations,
selections, and joins.  On the other hand, an adversary that
compromises a DBMS server may now learn information about the data,
such as relations between different rows in a table.  Thus, we need to
define privacy in a way that balances the need for server-side
computation with the need to minimize information revealed to the
server.

The third challenge lies in making an encrypted DBMS practical to use.
To provide good performance, an encrypted DBMS should impose minimal
performance overheads on the server, but at the same time avoid
offloading SQL query execution onto the client.  To make an encrypted
DBMS easy to deploy, an ideal system would also require {\em no
  changes to existing DBMS server software}, so that it can take
advantage of more than four decades of engineering and
optimization work, run over a range of commodity DBMS servers, as well as
\textit{as make no changes to client applications}.

We address these challenges in CryptDB's design using three key
ideas.  The first idea is an {\em SQL-aware encryption strategy}.  We
observe that SQL queries are composed of primitive operators, notably
order comparisons, equality checks, and addition.  For most of these
operators, we found existing encryption schemes in which the operation
can be performed on the ciphertext without knowing the decryption key.
One exception is joins, for which no cryptographic primitive existed;
in this case, we developed a novel cryptographic construction for
privacy-preserving joins.
Given these primitives, we encrypt each
data item with encryption schemes that enable the server to execute
the necessary SQL operators on that data.  This approach is both
efficient and practical, since the bulk of the DBMS, including query
planning, data layout, transaction coordination, and the structure of
the queries themselves, can remain the same, and only individual
SQL operators used by a query may need to change.

The second idea is {\em adjustable query-based encryption}, where
CryptDB dynamically adjusts the encryption level for each data
item at runtime, so as to achieve the maximum privacy
level given the user's queries.  In particular, CryptDB initially
encrypts all data with the strongest level of encryption, and,
as the application issues SQL queries, CryptDB adjusts the level
of encryption on the server, so that the server can perform the
classes of computations necessary for that SQL query.  This model
forms the basis of our privacy definition, ensuring maximum privacy
given the classes of computations required by the queries presented
to the DBMS, and avoids the need to modify application code to
declare the necessary level of encryption ahead of time.

The third idea is to implement adjustable query-based encryption by encrypting
each data item in an {\em onion of encryptions}, from weaker forms of
encryption that allow certain computations, to stronger forms of
encryption that reveal no information, as shown in
Figure~\ref{fig:onion}.  This approach allows CryptDB to efficiently
adjust encryption levels on the server without having to re-encrypt
all data at the client.  For example, the outermost layer uses
randomized encryption, which guarantees that the server can learn
nothing about the data, aside from its length.  If the user issues an
SQL query containing {\tt WHERE id=5}, CryptDB sends the server an
{\em onion key} to decrypt the {\tt id} column to a deterministic
encryption level, where identical plaintexts have identical
ciphertexts.\footnote{CryptDB never gives the server onion keys to
  decrypt the data to plaintext.}  CryptDB then sends the server a
deterministic encryption of the constant $5$, allowing it to compute
matching rows by only revealing the necessary {\em relations between
  data items}, and {\em not revealing the actual data}, or other relations
between data items not used in this query.


% Privacy and practicality are 
% conflicting goals. At one extreme, theoretical approaches using fully homomorphic
% encryption~\cite{gentryVerifiable} support any general computation
%  on encrypted data and provide strong privacy guarantees (e.g., the DBMS
% does not even learn access patterns). Unfortunately,
% such approaches are prohibitively impractical; for example, performing a simple
% string search using homomorphic encryption is about a trillion times slower than without
% encryption~\cite{trillion}. At the other extreme, providing no privacy by
% keeping the data in the clear, provides high performance and functionality.

% The idea for achieving practical privacy is \textit{to
% allow the database server to process queries on encrypted data as it would do on clear
% data}; when the server needs to evaluate a predicate on two encrypted data
% items, we empower the server to do so.

% In this model, each query requires the server to perform a certain class of
% computations on stored data. For example,
% consider evaluating an equality filter such as \texttt{WHERE id = 5}. Given
% the encryption of $5$, say \texttt{x1c5a21}, the server needs to be able to
% figure out what rows in column \texttt{id} have an encryption of
% \texttt{x1c5a21}.  CryptDB allows the server to compute the set of rows whose
% {\tt id} column matches the given ciphertext, but does not reveal to the
% server the original values, or what plaintext \texttt{x1c5a21} corresponds to.
% That is, CryptDB reveals the {\em relations between data} that the server needs
% to know to execute a type of query, but {\em not the actual data}, or any
% relations over encrypted data not queried by the user.

% As such, CryptDB provides maximum privacy given the classes of computations
% required for the user's queries.
% To the best of our knowledge, CryptDB provides stronger privacy guarantees than
% any previous work that is practical and as functional. CryptDB ensures that
% the database server only stores and
% manipulates encrypted data. By encrypting all data stored on the database server,
% the solution prevents the database administrator (DBA) from extracting private
% data, while still being able to manage and tune the database server.

% To enable the server to perform user-requested queries, we build on existing
% cryptographic tools, optimize others, as well as design a new
% cryptographic primitive. For example, any deterministic encryption scheme
% (denoted $\DET$) allows equality checks because
% the same value will be mapped to the same ciphertext. Any encryption scheme that
% preserves the order of the values encrypted (denoted $\OPE$) allows range
% queries. For joins, we design a new cryptographic primitive that enables the
% server to join only the columns requested by the user.

% A natural question arises: without {\em a priori} knowledge of the queries to be
% performed, how can we know how to encrypt the data? Each data field must be
% encrypted according to the operations
% that will be performed on it. Some applications have a fixed set of queries that
% will issue to the server; however, for some applications the mix of queries may
% be unknown or the set of queries may change (e.g., when
% adding new features). Recall that one of our goals is to run applications on top
% of CryptDB unchanged.

To our knowledge, CryptDB is the first private system to support all of 
standard SQL over encrypted data without requiring any
client-side query processing, modifications to existing DBMS
codebases, changes to legacy applications and offloads virtually all
query processing to the server. CryptDB works by rewriting SQL queries,
storing encrypted data in regular tables, and using an SQL user-defined function (UDF) to perform server-side
cryptographic operations.  We have implemented a prototype of CryptDB
that works with unmodified Postgres and MySQL databases.\footnote{In
  fact, CryptDB will work with any other unmodified commodity
  relational DBMS servers too.}  Porting CryptDB to a new database is
straightforward: our port to MySQL required changing just $86$ lines of
code.  Our experimental results demonstrate that CryptDB is portable
and imposes a $\tput$ penalty in throughput for a TPC-C workload compared
to an un-encrypted DBMS\@.  We view this overhead as relatively modest
and a tolerable penalty in many contexts where the desire for data
privacy is more important than achieving the highest level of
performance.

% In summary, this paper makes the following three contributions.
% First, we present the design and implementation of CryptDB, a novel
% and practical system for protecting data privacy in an untrusted DBMS
% server by storing only encrypted data on the server running SQL
% queries without decrypting the data on the server.  Second, we
% introduce the idea of adjustable security, optimize existing
% cryptographic tools for use in SQL queries, and develop a novel
% cryptographic technique for privacy-preserving joins.  Third, we
% evaluate CryptDB on a TPC-C workload \nz{and the database used by the
%   graduate admissions web site of our department, grad-apply, if we get
%   around to it}, and show that CryptDB requires no application changes
% and imposes a modest 28\% throughput overhead.  Moreover, in addition
% to not requiring any modifications to DBMS server software, we show
% that porting CryptDB entails only a modest amount of work: by changing
% just 85 lines of code (mostly connectivity code), we ported CryptDB
% from Postgres to MySQL.

%\begin{CompactEnumerate}
%  \item The design of CryptDB, a system that preserves privacy while allowing
%  SQL queries on encrypted data. CryptDB:
%  \begin{list}{\labelitemi}{\leftmargin=1em}
%    \item provides provable guarantees of privacy (Sec. \ref{s:model}),
%    \item provides more
%    functionality than previous practical schemes by engineering existing 
%    cryptographic tools,
%    optimizing others, and designing a new cryptographic tool for
%    private joins,
%    \item does not require modification of client applications or prior knowledge of 
%    queries by the new mechanism of \textit{adjustable security} (Sec.
%    \ref{s:design}),
%    \item requires virtually no client side processing.    
%  \end{list}
%  \item The implementation and evaluation of CryptDB on Postgres. CryptDB:
%  \begin{list}{\labelitemi}{\leftmargin=1em}
%    \item does not change the DBMS so it can be ported to any standard
%    DBMS\@. By changing $~85$ lines of code of CryptDB (mostly connection code
%    to the DBMS), we ported CryptDB to MySQL (Sec. \ref{s:impl}),
%    \item has a modest overhead with a throughput loss
%    of $\approx 28\%$ on TPC-C (Sec. \ref{s:eval}).
%  \end{list}
%\end{CompactEnumerate}

% \hb{Not sure we need this para...}
% The rest of this paper is structured as follows.  First, \S\ref{s:model}
% describes CryptDB's threat model.  \S\ref{s:design} presents CryptDB's
% design in more detail, and \S\ref{s:impl} discusses our prototype
% implementation.  Our experimental results are presented in \S\ref{s:eval}.
% We compare CryptDB to related work in \S\ref{s:related}, and conclude
% in \S\ref{s:concl}.



