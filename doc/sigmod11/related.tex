\section{Related Work}
\label{s:related}

At a high level, the main contribution of CryptDB over prior work is a
practical novel approach for guaranteeing data privacy in a DBMS\@.
To our knowledge, CryptDB is the first private system to support all the
operators used commonly in SQL, perform virtually all the query processing on
the server, work without modifying the internals of existing
relational DBMS codebases or client applications, and run at a fairly modest
performance degradation.

We divide related work into applied cryptography,  providing tools for
processing encrypted data, but not a comprehensive systems solution, systems
approaches done in the context of implemented designs, and theoretical
approaches.

% us. (2) A large part of the query must be resolved on the client side:
% the client finishes filtering selections and joins, as well as finish
% grouping values. This may require a large amount of data sent to the
% client and considerable client-side processing. In CryptDB, queries
% are completely evaluated on server side. (3) Such solution does not
% support some functionality like aggregates and search on strings.  (4)
% Importantly, the design of such a database changes radically the
% design of current databases that have been heavily optimized. (5) Such
% a database system has not been built to prove its practicality.


\vspace{-0.2cm}
\paragraph{Applied cryptography}
% There has been work on designing tools for searching on encrypted data
% and work proposing search on encrypted data for outsourcing DBMS
% privately~\cite{Dawn-Song-Search-2000, Chang04privacypreserving,
%   queriesEncryptionBoneh, private-query-multi-user-for-searchable,
%   amanatidis-boldyreva-o'neill, Yang-privacy-preserving-queries,
%   encrypt-for-secure-outsource}. 
% The work in~\cite{private-query-multi-user-for-searchable} also considers the
% multi-user case.
Over the past few years, researchers have developed cryptographic tools for
searching keywords over encrypted text~\cite{Dawn-Song-Search-2000,
queriesEncryptionBoneh} and some researchers have proposed using these tools to
process SQL queries on encrypted
data~\cite{private-query-multi-user-for-searchable,
 Chang04privacypreserving, encrypt-for-secure-outsource,
 Yang-privacy-preserving-queries}. These approaches are a good first cut at the
 problem, but are incomplete in substantive ways: they do not support many basic
 SQL queries, providing mostly only equality comparisons, most of
 them require significant client-side query processing, require changing the
 innards of a DBMS;  most are too inefficient, e.g., requiring
users either to build and maintain indexes on the data at the server or else to
perform sequential scans for every selection/search; finally, many remained at
the level of cryptographic protocols and did not build and demonstrate
a system. Nevertheless, these approaches are useful for private text search, and we use a
similar method for ``ILIKE'' to the ones in~\cite{amanatidis-boldyreva-o'neill,
Dawn-Song-Search-2000}; however, they do not constitute a complete or efficient
privacy-preserving DBMS\@.

% recognized that, for a
%privacy-preserving DBMS to be practical at all, one should be willing to reveal
%access patterns needed for the desired class of computation.  They also
%stressed the importance of formally specifying and proving the security
%guarantees of a system to prevent attacks, as we proceed in \name{}.  Their
%work is a cryptographic protocol that allows equality comparisons in a similar
%way to $\DET$ and some limited ranges.

Amanatidis et al.~\cite{amanatidis-boldyreva-o'neill}, slightly different from
the schemes above, allow the server to build indexes, but their privacy
is significantly lower than CryptDB's: they reveal {\em a priori} all repeating values and all common ranges
(same prefix values) in the whole database (across all columns and rows). Key to our security is the
dynamically-adjustable encryption based on queries: fields that are never used
in range queries or equalities should remain encrypted with the strongest
encryption scheme. Finally, they do not support all other queries besides
equality and prefix-based ranges, and did not build a system.

In addition, the privacy provided by the most secure of these
previously developed schemes is approximately similar to CryptDB\@.  For
example, in Yang et al.'s work~\cite{Yang-privacy-preserving-queries},
after one query has been made, the server only knows the repetitions
of the constant in the selection filter, and does not know all the
repetitions of data in a column as in CryptDB\@.  Therefore, after one
equality query, their protocol is more secure. However, after a few
different queries with the same structure, but different constants,
CryptDB reveals as much information as their approach. These are
specific tools and do not enable to server to perform other
requirements in a DBMS: general range queries, updates of a whole
column or range of tuples (e.g. increments), aggregates, some cannot
support joins.

There is also work allowing the server to build secure
indexes~\cite{goh03} on encrypted data without having access to the
data. These approaches require significant changes to the DBMS and would not be
as portable. Moreover, due to complex cryptographic tools they are
slower. In our case, the server builds indexes naturally as it would
on typical (longer) numbers. Ge and Zdonik~\cite{c-store-index} enable
comparisons and designs indexes for a column store.

There has been work on processing queries on encrypted
XML~\cite{Wang-xml, querying-encrypted-XML}. This work provides useful
security semantics for XML data, but requires a cumbersome DBMS
rewrite.
% When applying it to the general
%setting of outsourced databases, there are the following issues: they
%change query processing at the server and requires a rewrite of the
%DBMS\@. 
Moreover, the results sent to the client are a superset of the true
result, requiring the client to perform additional post-processing.
%which can sometimes be time consuming and bandwidth wasteful. 
They also do not discuss updates and inserts.
%, and some are in fact
%search on encrypted data and suffer from similar issues as above when
%applying in our context.

\vspace{-0.2cm}
\paragraph{Systems approaches} 

While early proposals attempted to enable SQL processing over
encrypted data, their privacy mechanisms were
heuristic without formal guarantees, required a significant rewrite of the DBMS
design, relied on considerable client-side processing, and did not support a
wide range of SQL queries.

In~\cite{sqlOverEncryption}, Hacigumus et al. split the domain of
possible values for each column in partitions. Each partition has a
number (random or order-preserving) and each value is replaced with
the number of the partition.  The actual tuple is stored
encrypted.  By grouping elements in
partitions, privacy may be compromised because an untrusted entity may
well know which elements are close to each other in value. The more partitions, the more useful work the server does,
but the less privacy clients have. With our
dynamically-adjustable encryption mechanism, we do not reveal relations for
columns not used in a filter.

%Using these partitions, a server
%tries to process as much of a SQL query as possible, leaving the
%remaining processing for the client.

Ozsoyoglu et al.~\cite{Ozsoyoglu03anti-tamperdatabases} use
user-defined functions and do not require changes to the DBMS
software. However, their approach only applies to integers, does not
support joins (must be processed at the client), do not discuss
updates and inserts.  Importantly, they  encrypt fields with a
\textit{distance}-preserving encryption function for which $a-b = E(a) -
E(b)$. Such scheme is not secure because the mere knowledge of one
value $a$ for an encryption $E(a)$ leaks the decryption of all other encrypted
values.

Damiani et al.~\cite{damianiIndex} provide a solution for processing
range queries over encrypted data.  Each element in a tuple is
encrypted and hashed to a small number of buckets to improve
privacy. Range queries can be computed using a B+ tree, but these are
done by the trusted client that needs to traverse the B+ tree by
sequentially performing queries at the server. Such work does not
support joins, aggregates, or string searches.

% TODO: may want to mention work on splitting values over two dbs, requesting
% multiple queries -- these are heuristics and do not help

Ciriani et. al~\cite{Ciriani09keepafew} propose a new approach to
confidentiality: replacing data encryption with fragmentation; they
store a part of the data at the trusted client (e.g. sensitive columns
or relations between columns) and the rest of the data unencrypted at
the untrusted server, thus avoiding encryption altogether. However,
each client (trusted) has to store a potentially large amount of data
locally and has to perform query processing whenever sensitive data is
involved in a query. 
%Moreover, as seen in Section \ref{s:eval}, one
%can use encryption at reasonable overheads.

Chow et al.~\cite{two-party-computation} require the presence of two
additional parties, a randomizer and a query engine, which are assumed
not to communicate; moreover, the data is stored at multiple DBMSs
that do not trust each other. The security of their protocols hinge on
such security assumptions and on no collusions happening; such a
setting is not always possible, and solutions without such strong
trust assumptions may be desirable.


\vspace{-0.2cm}
\paragraph{Theoretical approaches}
Theoretical solutions promise a high degree
of security, however, they are prohibitively impractical. Recent
work~\cite{gentryVerifiable} based on fully homomorphic
encryption~\cite{fullyHom} enables
an untrusted party to perform any general computation on encrypted data (such
computation could be query processing) without leaking even access patterns to
the data. Unfortunately, as an example, performing a simple string search using
homomorphic encryption is about a trillion times slower than without
encryption~\cite{trillion}.

Work in PIR~\cite{pir-survey} allows a user to request a tuple from the database
without the server learning what tuple was requested. While they provide
excellent security, such approaches are highly infeasible because, for each
tuple requested, the server must scan the whole database.

\paragraph{Other work} 
There has been a significant body of work on distributed privacy
preserving data integration, aggregation, and mining: constructing
decision trees \cite{Lindell-Pinkas-Secure-Data-Mining}, computing
association rules, classification and
clustering~\cite{Vaidya-Clifton-2002, Kantarcioglu-Clifton-2004,
  Kantarcioglu-Clifton-2005, Yang-2005}, outsourced data
aggregation~\cite{Xiong-2007}
and~\cite{Thompson_privacy-preservingcomputation}.  These works
provide a rich and useful set of privacy-preserving tools for
different purposes than \name, and they can be used together with
CryptDB\@.

Work on differential
privacy~\cite{dwork-survey,mcsherry:pinq,roy:airavat}, introduced by
Dwork and enhanced by Miklau~\cite{miklau-diff-private}, as well as
privacy in statistical databases, allows a trusted server to decide
what answers to release or how to obfuscate answers to aggregation
queries to avoid leaking information about any specific record in the
database. Such work has a different goal and model from CryptDB; in
fact, one can add differential privacy to the front end in CryptDB to
provide to users only privacy-preserving answers.
