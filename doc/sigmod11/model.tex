\section{Threat Model}
\label{s:model}

% As described in the previous section,
The goal of CryptDB is to ensure
the \textit{secrecy} of data in an SQL database in the face of \textit{an
adversary that has complete access to the database server}. The adversary could
compromise the server software, or even physically attack the server by stealing
and reading disks. Consequently, CryptDB makes \textit{no assumptions about the
database server keeping any data private}. This model covers all of the
motivating scenarios we have mentioned so far, such as outsourcing a SQL
database to the cloud, protecting against a curious database administrator,
and guarding against attackers breaking into the database server machine.
On the other hand, CryptDB assumes that the application and the CryptDB
frontend (Figure~\ref{fig:architecture}) are not compromised, and do not
reveal their keys to the adversary.  Dealing with attacks on these components,
such as SQL injection vulnerabilities or authentication bypass attacks, is
outside of the scope of this paper.

For the purposes of this paper, we assume that a malicious server does not
change the data or query results.  Ensuring integrity for SQL queries has
been heavily researched, and we refer to prior literature for techniques
to achieve integrity, as follows.  Since CryptDB allows the DBMS to process
relational queries on encrypted data as it would on plaintext data, most
previously-proposed approaches can be readily used with CryptDB\@.
A malicious server can affect three aspects of data security:
integrity, freshness, and completeness. Integrity is solved by adding
a MAC to each tuple as in~\cite{li:sundr,plutus,sirius}. Freshness
has been addressed using Merkle hashes or chained
hashes~\cite{plutus,cloudproof,sirius} and both freshness and
completeness of query results are addressed in~\cite{queryassurance}.
Also,~\cite{Li-Reyzin-06authenticatedindex}
and~\cite{Thompson_privacy-preservingcomputation} allow the client to verify
results of aggregation queries, \cite{authenticate-join} authenticates joins,
and~\cite{sion-assurance} provides query assurance for most read queries.

% Outside of the DBMS server, CryptDB assumes that the client frontend is fully
% trusted to keep its keys private. As we will see, the frontend does little
% work: it simply encrypts and anonymizes queries, but does not execute them.
% Hence, we believe this is a reasonable assumption, because a shared database
% server in the cloud is both a more compelling target for an attacker,
% and is more exposed than an individual (application) server.
% Moreover, keeping a server private is much easier than keeping the data of
% many database machines private.  Furthermore, for cases in which an enterprise
% hosts a frontend in their local cluster, and outsources their database to the
% cloud, access to the frontend may be considerably hard to achieve from outside
% of the enterprise as compared to gaining access to the cloud DBMS\@.

\subsection{Security Definition}\label{s:def}

\textbf{Intuition}. At a high level, CryptDB's definition of privacy says
that \name{} only reveals the relations between tuples needed by the server
to perform certain computations; in other words, CryptDB provides
\textit{maximum privacy given the classes of computations needed at the
server} to process SQL queries.  More specifically, the definition says
two things:
\vspace{-0.15cm}
\begin{itemize}
  \item If users request no relational predicate filtering 
on a column (i.e., they only request projections and computation),
nothing about the column content is leaked; if the user requests equality checks
on a column, we reveal which items repeat in that column;
if the user requests inequality checks on a column, we reveal the order
of the elements in the column.  We never reveal the actual data content.

\item The server cannot
process queries (that is, discover new data relations) different from the ones
requested by the user.
\end{itemize}
\vspace{-0.15cm}
This intuition suffices to grasp CryptDB's security model, so the
reader uninterested in formalism can proceed to the ``Implications''
part of this section below (and perhaps return to the formal definition
of security later).

\textbf{Definition.}
To formalize cryptographic definitions, often times one defines an
\textit{ideal world} using oracles and then proves that the proposed protocol
has as much privacy as the ideal world with respect to
polynomial-time adversaries. We will instead use the term \textit{ideal
system}.

What is the ideal system considering our goals? It is a system in
which the server only learns the data relations that it needs in order to perform
typical SQL processing for user queries, and nothing else. This is equivalent to
the server having access to \textit{no data content}, but only to an oracle that
is willing to answer questions about the relations between data items, restricted
only to questions needed to process requested queries.

Given a query $Q$, let $\fu(Q)$ be the classes of computations needed by
$Q_i$; that is, the relations between tuples that the server is allowed
to know to process
the query. For example, if $Q$ is \texttt{SELECT * FROM table1, table2 WHERE
table1.c1 = table2.c2}, then $\fu(Q)$ consists of questions of the form: ``is
the $i^\mathrm{th}$ item in c1 equal to the $j^\mathrm{th}$ item in c2''.
Obviously, the server
needs to know this information to process a join, but it does not need to know
the actual value of the two items. In the Appendix, we describe $\fu$ precisely.

\begin{definition}[Ideal System]\label{def:sec}
Let $Q_1 \ldots Q_t$ be the queries users requested up to time $t$. The
database at the server consists of each data item encrypted with the strongest
encryption scheme (random). Moreover, the
server has access to an oracle that only answers questions from $\fu(Q_1) \cup \ldots \cup \fu(Q_t)$.
\end{definition}

Obviously, in the Ideal System, the server can process SQL queries on encrypted
data because all the information it needs are the relations in $\fu(Q_1)
\cup \ldots \cup \fu(Q_t)$, by the definition of $\fu$. At the same time, such
server always has the database encrypted with the strongest encryption scheme
that leaks nothing.

We want the server in \name{} to learn as much information as the server in the
Ideal System and we show this property in \S\ref{s:analysis}.

\textbf{Implications.} While CryptDB does not reveal any data item, it does not
hide data access patterns.  For example, the database server can
monitor the frequency with which some data item is returned in a result set.
Masking such access patterns from the server would incur significant
overhead~\cite{pir-survey}, require virtually an
overwrite of the underlying DBMS, add considerable client-side
processing, and preclude server-side optimizations. 

CryptDB's database server can also check any predicates used to
execute past user-requested SQL queries, both at the time the query is executed,
and at any later time.  For example, if the application were to
issue the query {\tt SELECT * FROM table1 WHERE c1 = x2ad412}, the server
would be able to check rows for this predicate; however, this will be mostly
useless to the server because \texttt{x2ad412} is an
encrypted value and all that the server learns is the number of rows that match
this unknown constant.

Note that, when the server needs to evaluate a predicate $P$ (say,
\texttt{id = x245ab1?}), the server is allowed to perform the class
of equality check computations on column {\tt id} (albeit checking for
equality with an encrypted value) rather than just the computation of
checking for a specific value.  As such, the server can check
predicates of the form \texttt{c1 = *}, where $*$ is any ciphertext,
but whose corresponding value the server does not know.  Therefore,
what the server learns is the frequency of repeats of values only in
column \texttt{c1}.

We considered allowing the server to check equality only for the
specific constant given by the user, but cryptographic primitives supporting
equality checks in this way are very expensive. Moreover, doing so will not
bring much additional privacy. The reason is
that, typically, user queries end up performing selection on the same column for
a variety of different constants; after a few such queries, the privacy of this
seemingly-stronger scheme will converge to the privacy of our scheme.

\subsection{User-enforced Security}

% \nz{This is really more of a safeguard against bugs in applications that
%     issue queries they did not mean to..  The threat model / security
%     guarantees remain the same, so we could move this text to design or
%     implementation.}

In certain applications, it may be difficult for a programmer to find
all of the queries issued by the application, making it difficult
to reason about the precise privacy guarantees that CryptDB will
provide.  In this case, CryptDB allows the programmer to optionally
annotate the schema (in the frontend, as defined in the next section)
by specifying the lowest security level allowed for each column.
For example, the programmer may allow equality checks, but may not
want to reveal order within the column.  In this case, CryptDB will
not allow the server to perform inequality checks, and reject any
query that requires such computations.

% Specifically, the programmer can annotate each column $c$
% in the schema using operations $>, <, =$ and security levels \texttt{order},
% \texttt{repeats}, and \texttt{random} (or full privacy).  For example,
% \texttt{c > order} means that order of
% items in column $c$ should not be revealed, but repeats can be revealed. The
% frontend will make sure not to provide capabilities to the server for lowering
% privacy beyond the repeats point.
%If a programmer intends to
%allow the user application to make requests needing more functionality than
%he imposed as minimum in the schema, he needs to make adequate provisions for
% such queries to be processed client-side or somewhere else.

