% !TEX root = paper.tex

\section{Multiple Principals}
\label{s:multi}
\label{sec:multi}

We now extend the threat model to the case when the application
infrastructure and proxy are untrusted.  This model is especially
relevant for a multi-user web site running a web and application
server.  To explain the problems encountered by a multi-user web
application and \name{}'s solution to these problems, consider phpBB,
a popular online web forum.  Each user has an account and a password,
belongs to certain groups, and can send private messages to other
users. Depending on their groups' permissions, users can read entire
forums, only forum names, or not be able to read a forum at all.

There are several confidentiality guarantees that would be useful
in phpBB\@.  For example, ensuring that a private message sent from
one user to another is not visible to anyone else; ensuring that
posts in a forum are only accessible to users in a group with access
to that forum; and ensuring that the name of a forum is only shown
to users belonging to a group that's allowed to view it.  \name{}
provides these capabilities in the face of arbitrary compromises,
limiting the damage caused by a compromise.

There are two main problems.  First, \name must make it easy to
express policies like the ones above.  Rather than require intrusive
additions to the code, we allow the developer to annotate the database
schema (\S\ref{ss:policy}).  Second, \name must encrypt the data with
several different keys; otherwise, an attacker that compromises the
proxy or application server can decrypt all data.  However, simply
encrypting each data item with a single user's key does not work: in
our example, forum posts must be shared between users, and the set of
users with access to a forum may change at runtime.

Our solution limits the leakage resulting from a compromised
application or proxy to only the data accessible by users who were
logged in during the compromise.  The amount of data leaked
in our solution seems unavoidable given our assumptions about the
impracticality of fully-homomorphic encryption: the relevant data
must be decrypted whenever the web application performs arbitrary
computations to service the requests of active users.

\name{} encrypts different data items with different keys, according
to the specified policies.  \name{} enforces the policies, which
involve multiple users being able to read/write any given data item,
at run-time by encrypting and decrypting the required keys, starting
from the password of the user and ending at the desired keys,
following a chain of keys (\S\ref{ss:keychain}).

%%% The next three paras are the prev version

% We now extend the threat model to the case when the infrastructures
% hosting the application and the proxy are untrusted.  This model is
% especially relevant for a multi-user web site, which in general would
% include a web server and possibly an application server.  If an
% attacker compromises the proxy or the entity querying the DBMS, it can
% gain access to the master key and read all the data.  Our goal is to
% reduce the degree vulnerability so that a compromise doesn't cause as
% much damage.

% Our solution limits the leakage resulting from a compromised
% application or proxy to the data accessible by users who are
% currently active (i.e., logged in after explicit authentication); the
% data belonging to all other users remain protected.  The amount of
% data leaked in our solution seems unavoidable given our assumptions
% and constraints. Because performing arbitrary computations on
% encrypted data, which required fully-homomorphic encryption, is
% currently neither practical nor believed to become practical
% soon~\cite{trillion}, the relevant data should be decrypted whenever
% the web application needs to perform arbitrary operations (as is the
% case in general) to service the requests of active users.

% \name{} replaces the proxy's master key with multiple different keys
% and encrypts different data items with different keys, according to
% policies expressed over the database schema by the application
% developer (\S\ref{ss:policy}).  Then, \name{} enforces the policies at
% run-time by encrypting and decrypting the required keys, starting from
% the password of the user and ending at the desired keys, following a
% ``chain'' of keys (\S\ref{ss:keychain}).


% The solution is to replace the \frontend{}'s master key with many
% ``client keys'': each client of the application stores a client key,
% which only enables the client to access the data it is entitled to
% according to application logic. To enable the application to perform
% arbitrary computation on user data, each client gives its key to
% \name's \frontend{} for the duration of its session. Therefore, if an
% adversary compromises the application, he can only read the data of
% clients that are currently active; the data belonging to the other
% clients remains protected.


% TODO: in Facebook users are logged in all the time, so maybe we want
% to do this at the granularity of sessions


\subsection{Policy Annotations}
\label{ss:policy}

To express the privacy policy of a database-backed application at the
level of SQL queries, the application developer can annotate the
schema of a database in \name{} by specifying, for each subset of data
items, which {\em principal} has access to them.  A principal is an
entity, such as a user or a group, over which it is natural to specify
an access policy.  Each SQL query involving an annotated data item
requires the privilege of the corresponding principal. 

% \name relies on the notion of a {\em principal}, an entity involved in
% access control, for example, a user or a group.  Private data items in
% an SQL database can be marked as accessible only to a particular
% principal, and each SQL query involving the private data item requires
% the privilege of that principal. Programmers express the policy of
% their application in terms of principals, by annotating their SQL
% schema in four steps, 

An application developer annotates the schema using the steps
described below and shown in Figure~\ref{fig:privmsg}.

\renewcommand{\FrameSep}{0.05in}
\begin{figure}[t!]
\begin{framed}
\footnotesize

\begin{tabbing}
{\bf PRINCTYPE physical\_user EXTERNAL;} \\
{\bf PRINCTYPE user, msg;} \\
\\

x \= msgtext \= varchar(255) \= \kill

CREATE TABLE privmsgs (\\
\> msgid \> int, \\
\> subject \> varchar(255) \> {\bf ENC\_FOR (msgid msg)}, \\
\> msgtext \> text \> {\bf ENC\_FOR (msgid msg)} ); \\
\\

CREATE TABLE privmsgs\_to (\\
\> msgid int, ~ rcpt\_id int, ~ sender\_id int, \\

\> {\bf (sender\_id user)} \= {\bf HAS\_ACCESS\_TO (msgid msg)}, \\
\> {\bf (rcpt\_id user)} \> {\bf HAS\_ACCESS\_TO (msgid msg)}); \\
\\

x \= sender\_id  int, x \= username varchar(255), x \= sender\_id text \= \kill

CREATE TABLE users (\\
\> userid int, ~ username varchar(255), \\
\> {\bf (username physical\_user) HAS\_ACCESS\_TO (userid user)});

\end{tabbing}

\vspace{-4mm}
\hrulefill
\vspace{-2mm}

\begin{center}
\textit{Example table contents, without anonymized column names:}
\end{center}
 \hspace{1mm}
 \begin{minipage}[h]{1.7 in}
  \centering
  \begin{tabular}{p{0.8cm}|p{1cm}|p{0.8cm}}
  msgid & subject & msgtext \\ \hline
  5 & xcc82fa & x37a21f \\ 
  \end{tabular}

  \smallskip

  \begin{tabular}{p{0.8cm}|p{1cm}|p{0.8cm}}
  msgid & rcpt\_id  & sender\_id \\ \hline
  5 & 1 & 2 \\ 
  \end{tabular}
\end{minipage}
\hspace{0mm}
\begin{minipage}[h]{0.9in}
 \centering
  \begin{tabular}{c|c}
  userid & username \\ \hline
  1 & `Alice'  \\  
  2 & `Bob' 
  \end{tabular}
 \end{minipage}
\end{framed}

\caption{
Part of phpBB's schema with annotations to secure private messages.
Only the sender and receiver may see the private message. An attacker
that gains complete access to phpBB and the DBMS can access
private messages of only currently active users.  Bold text indicates
annotations added for \name.
    }
\label{fig:privmsg}
\end{figure}

{\em Step 1.} The developer must define the {\em principal types}
({\small \tt PRINCTYPE}) used in her application, such as users,
groups, or messages.  A {\em principal} is an instance of a principal
type, e.g., principal 5 of type user.  Principals are of two types:
external and internal. External principals correspond to end users who
explicitly authenticate themselves to the web site using a password.
When a user logs into the application, the application must provide
the user password to the \name proxy so that the user can get the
privileges of his external principal.  Privileges of other (internal)
principals can only be acquired through delegation, as described in
the Step 3.  The application also informs the proxy when the user logs
out.

{\em Step 2.} The developer must specify which columns in her SQL
schema contain sensitive data, along with the principals that should
have access to that data, using the {\tt \small ENC\_FOR}
annotation.  \name requires that for each private data item in a row,
the name of the principal that should have access to that data be
stored in another column in the same row.
% That principal is typically a (primary) key column of the table.
For example, in Figure~\ref{fig:privmsg}, the decryption of {\em msgtext}
\texttt{x37a21f} is only available to principal 5 of type {\em msg}.

{\em Step 3.}  Programmers can specify rules for how to delegate the
privileges of one principal to other principals.  For example, in
phpBB, a user should also have the privileges of the groups he belongs
to.  Since many applications store such information in tables,
programmers can tell \name to infer delegations from rows in an
existing table.  In \name, programmers can annotate a table $T$ with
{\tt \small ($a$ $x$) HAS\_ACCESS\_TO ($b$ $y$)}.
This annotation indicates that each row present in that table grants
principal $a$ of type $x$ access to everything that principal $b$ of
type $y$ can access.  Here, $x$ and $y$ must always be fixed principal
types.  Principal $b$ is always specified by the name of a column in
table $T$.  On the other hand, $a$ can be either the name of another
column in the same table, a constant, or $T2.\textrm{col}$, meaning {\em all}
principals from column $\textrm{col}$ of table $T2$.  For example, in
Figure~\ref{fig:privmsg}, principal ``Bob'' of type {\em
  physical\_user} has access to principal 2 of type {\em user}, and
in Figure~\ref{fig:hotcrp}, all principals in the {\em contactId}
column from table {\em PCMember} (of type {\em contact}) have access
to the {\em paperId} principal of type {\em review}.  Optionally, the
programmer can specify a predicate, whose inputs are values in the
same row, to specify a condition under which delegation should occur,
such as excluding conflicts in Figure~\ref{fig:hotcrp}.
\S\ref{s:apps} provides more examples of using annotations to secure
real applications.


%The task of the developer only consists of annotating the schema and
%informing \name's \frontend{} of when users login (and providing their
%passwords) and logout. 

To aid debugging, we allow the developer to provide a SQL trace of a
previous run of the application that also includes when users logged
in or out, and the proxy can verify if previous queries are permitted
to run given the current annotations, and flag whether the developer
should revise the annotations.

% \name{} needs to know what clients should have access to what data
% from the database in order to encrypt the data with appropriate keys.
% Since such policy is dictated by application logic, the programmer of
% the application should specify such policy.

% We provide a simple \textit{annotation scheme} using which \textit{the
% programmer can annotate the schema of the tables} in the DB. We show
% how a programmer can naturally express application access control to
% the data in the database using this scheme.

% The programmer should annotate any column whose data items are involved
% in access control. There are four types of annotations, which we will
% exemplify with a real scenario from phpBB in Figure~\ref{fig:privmsg}.

% \noindent -- \pr{}: denotes any class of entities involved in access
% control. Annotating column $c$ with \pr{} $P$ denotes that each item in
% column $c$ is an instance of a principal of type $P$. In our examples,
% principals are users and messages. For instance, column users.userid
% contains principal user instances $1$ and $2$. A column can be annotated
% with multiple principals (see \S\ref{s:apps}).

% \noindent -- $c$\ \encfor\ $P$: stands for \textit{encrypted for}
% principal $P$. There must be a column annotated with principal $P$
% in the same table. Each data item in column $c$ will be encrypted and
% only accessible to the instance of principal $P$ in the same row. For
% example, msgtext  x37a21f6732 can only be decrypted by Principal msg
% 5. Any number of columns can be encrypted for the same principal, such
% as msgtext and msgsubject.

% \noindent -- $P_1$ \access{} $P_2$, where $P_1$ and $P_2$ are principal
% annotations in the same table, denotes that each instance of  principal
% $P_1$ has access to anything that the instance of principal $P_2$ in the
% same row has access. An annotation for principal $P_2$ must be present
% in the same table.  For example, in table privmsgs\und{}to, principal
% user 1 and 2 have access to anything that principal msg 5 has access.

% \noindent -- \gives{} P: is added to a column containing names of clients
% or other physical entities who will be providing a password when they
% login to the system. Each password will be used for the instance of
% principal $P$ in the same row. For example, in table users, when Alice
% logs in, her password will be used for Principal user 1.

% Two principal instances from two different tables are equal if they are
% of the same type and have equal value.

% A client Alice has access to data item $d$ in column  $c$ if there is
% a valid path from the \gives{} record corresponding to Alice to the
% principal instance for which $d$ was encrypted. A valid path consists
% of \access{} links in the same row of a table or equality of principal
% instances across different tables. We can see both Alice and Bob have
% access to decrypt msgtext x37a21f6732, but, say a third user Chris with
% userid 3, would not have access to the data.

% To support more general policies, \name{} allows ``conditional'' \access{}
% annotations: \access{} followed by ``if Pred()'', where Pred() is a
% boolean SQL user-defined function by the programmer taking as input a
% row of the table on which it is defined. \name{} evaluates Pred() on
% each row; for the rows where Pred() is true, \name{} grants the access
% in question to the principal instances in that row. Inside Pred(),
% the programmer can perform arbitrary SQL queries.

% For sophisticated access control schemes, Pred() may contain SQL queries
% touching principals in another table, say $t$. At some later time, after
% access is given, an application administrator may change certain values
% in $t$ and the value of the predicate may change. \name{} thus must
% re-evaluate the predicate for each of the specific principals affected
% by the administrator's change. However, such changes may never occur
% (for applications who setup the access control policy at system setup)
% such as HotCRP or they can happen rarely (e.g., when the administrator
% bans a user) as in phpBB.

% The only changes needed to the application are such schema annotations
% (and any predicates' definitions) and authentication: the application
% should inform \name when a user logs in or out and provide it with
% the password (implemented via simple INSERT or DELETE from a fake table).

% \S\ref{s:apps} provides more examples of using annotations to secure
% real applications.

\subsection{Key Chaining}
\label{ss:keychain}

Each principal (i.e., each instance of each principal type) is associated
with a secret, randomly-chosen key.  If principal B has access to
principal A, then principal A's key is encrypted using principal B's
key, and stored in a special \texttt{access\_keys} table in the database.
In this way, principal B has access to principal A's key.  For example,
in Figure~\ref{fig:privmsg}, to give users 1 and 2 access to message 5,
the key of {\em msg} 5 is encrypted with the key of {\em user} 1, and
also separately encrypted with the key of {\em user} 2; both encryptions
are stored in \texttt{access\_keys}.  Each sensitive
field is encrypted with the key of the principal in the {\small \tt
ENC\_FOR} annotation. \name{} encrypts the sensitive field with
onions in the same way as for single-principal \name,
except that onion keys are derived from a principal's key as opposed to
a global master key.

The key of each principal is  a combination of a symmetric key
and a public--private key pair.  In the common case, \name uses the
symmetric key of a principal to encrypt any data and other principals'
keys accessible to this principal, with little CPU cost.  However, this is not always
possible, if some principal is not currently online.  For example,
in Figure~\ref{fig:privmsg}, suppose Bob sends message 5 to Alice, but
Alice (user 1) is not online.  This means that \name does not have access
to user 1's key, so it will not be able to encrypt message 5's key with
user 1's symmetric key.  In this case, \name looks up the public key
of the principal (i.e., user 1) in a second table, \texttt{public\_keys}, and encrypts
message 5's key using user 1's public key.  When user 1 logs in, they
will be able to use the secret key part of their key to decrypt the
key for message 5.

For external principals (e.g., physical users), \name assigns a
random key just as for any other principal.  To give an external user
access to the corresponding key on login, \name stores the key of each
external principal in a third table, \texttt{external\_keys}, encrypted
with the principal's password.  This allows \name to obtain a user's
key given the user's password, and also allows a user to change his or
her password without changing the key of the principal.

In \name{}, one user can grant a second user access to principal $P$
only if the first user already has access to $P$ himself.  At the
cryptographic level, this means that the first user must have $P$'s
key in order to re-encrypt it for the second user.  This closely
follows real-world semantics, since if someone can grant others
access to $P$, they can also grant themselves access to $P$.

When encrypting data in a query or decrypting data from a result,
\name{} follows key chains starting from passwords of users logged in
until it obtains the desired keys. As an optimization, when a user
logs in, \name{}'s proxy loads the keys of some principals to which
the user has access (in particular, those principal types that do not
have too many principal instances---e.g., for groups the user is in,
but not for messages the user received---which \name determines by
keeping aggregate statistics).

Applications inform \name{} of a user logging in or out by simply
issuing SQL {\tt INSERT} and {\tt DELETE} queries to a special
table \texttt{cryptdb\_active} that has two columns, {\tt username}
and {\tt password}.  The proxy intercepts all such queries for
\texttt{cryptdb\_active}, stores the passwords of logged-in users in
memory, and never reveals them to the DBMS server.

\name{} guards the data of inactive users at the time of an
attack. However, some special users such as administrators with access
to a large pool of data enable a larger compromise upon an attack.  To
avoid attacks happening when the administrator is logged in, the
administrator should create a separate user account with restricted
permissions when accessing the application as a regular user. Also, as
best practice, an application should automatically log off users who
have been inactive for a while.

% In a more complex access control scheme, the programmer might define an SQL predicate for the \small{HAS\_ACCESS\_TO} annotation to touch rows outside of the current row or table. If those tables or rows are changed dynamically (for example, when an administrator changes access control), \name must re-evaluate the predicate for the specific principals involved and add or remove access to relations; however, this case either did not happen in the real applications we evaluated or it happened rarely.

%EVEN say about the predicate being reevaluated??



% TO explain: join operations on columns with differntely encrypted data
% --  only on behalf of a person -- in general if a person has access it
% can be performed

%\subsection{Discussion}


% When the administrator needs
% to use the more powerful account for rare permissions changes or other
% management, the administrator should login at arbitrary times and,
% whenever possible, to make the website unavailable for maintenance for
% a short period of time at a time when it likely is not used.

%Passive attackers snooping on data may try to collect data
%of many users that log in over a period of time.  However, the
%first time \name's proxy receives a query for which it does not
%have sufficient keys, such as in an SQL injection attack, the
%proxy reports it as an attack.  If the administrator reacts quickly,
%the opportunity for the attacker to collect
%confidential data will be greatly reduced.

