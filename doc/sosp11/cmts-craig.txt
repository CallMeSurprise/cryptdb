1.       Tiny grammatical issues:

 

a.       page 4, section 3.1, paragraph on DET.  My copy states: "DET has a
slightly weaker guarantee, yet is still has strong security."   I'm guessing
it should read "yet it still has strong security.

 

b.       page 3, section 2.1, 2nd paragraph, 2nd sentence:  "In so doing,
the proxy uses some secret keys to encrypts . I'm thinking it should read
"to encrypt". 

 

2.       The paper does a decent job of highlighting its key points: (1)
queries over encrypted data, (2) onions, (3) chaining.  This is stated
clearly in the conclusion/recap.  But the onions idea gets glossed over in
two places.  In the Abstract, we read "read the 1st and 3rd idea, but not
the 2nd.  In the Introduction (page 2, left column, 2nd paragraph) we have
"CryptDB addresses these challenges using three novel ideas.  The first."
The following paragraph describes the onions of encryption but never states
it's the 2nd idea.  Then the next paragraph starts "The third idea" . which
sent me back looking for the 2nd idea.      Making it easy for readers
probably trumps boring prose.  

 

3.       Figure 1 is very helpful.  The text in section 2 "Security
Overview" states: "CryptDB works by intercepting all SQL queries in a
database proxy."   That's consistent with Fig. 1 - and seems vital, because
having a mix of plaintext and ciphertext in the same column seems likely to
result in wrong answers.  But this raises some questions:  (1) what
mechanism precludes DBMS connections that don't go through the proxy?  (2)
Is the proxy a bottleneck?  Is there a proxy per user?  Per application?
Per application server?  Is there a pool of proxies?

 

4.       Section 2 "Security Overview" states: "The proxy encrypts and
decrypts all data".  This seems to assume that all new data flows into the
DBMS through the proxy.  But there can be data sources that originate within
the DBMS server: triggers, UDFs, stored procedures, and references to
objects external to the DBMS, possibly in other DBMSs.   I suppose trigger
creation and UDF creation could also flow through the proxy, which could
block any data generation... but that may be a hard problem to take on.

 

[Prejudice disclosure:  data manipulation should occur as close to the data
as possible, while de/encryption should occur as close to the user as
possible.  Bringing data back to an application server is a bad idea if the
processing can be implemented as a UDF in the DBMS.  If 

(1)     there were information resources available only on the application
server; and 

(2)     significant computation was needed to combine the encrypted
information from the DBMS with the AS's information; and 

(3)     it's too much work to encrypt the AS's information and send it to
the DBMS for combination in a UDF, 

then it makes sense to decrypt in the AS.  In other cases, I'd prefer the
application/web server to function as a caching layer and protocol
translator (xxxML/JSON <-> SQL) (or the C part of MVC), packaging the
encrypted data for transport back to the user's machine, to be decrypted
there.  ] 

 

5.       Section 2.1, raised eyebrow at third bullet:  "The DBMS server
cannot process queries different from the ones requested by the
application".  It would be normal for the DBA to execute various queries in
service of routine maintenance and performance tuning.  So long as the
results are opaque, why is it important to block queries that don't
originate in the application/proxy?   Second, how can queries that are not
requested by the application, be precluded?

 

6.       Section 2.2, paragraph 1: "an adversary compromising the AS can get
access to the keys used to encrypt the entire database."  In my
cryptographic ignorance, I keep wondering whether it would be better to have
the final decryption keys at the client rather than in the proxy. Hari, I'd
asked previously whether an asymmetric scheme would help with this:

 

a.       Anyone with query permissions to a particular set of tables would
be given a private key stored on user-computers

b.       Anyone with insert/update/delete permissions to that set of tables
would be given a public key stored on the proxy.  

c.       The public/private keys are given on a role/principal basis.  They
could be stored at a different site than the AS/DBMS.

d.       The encryption could occur within the proxy, the final decryption
back at the client.  

e.       This would seem to avoid loss of information after an active
adversarial compromise.  

 

7.       Section 3, 2nd paragraph, 3rd sentence: "The DBMS's query plan for
an encrypted query is the same as for the original query".  I'd suggest
softening this: "is typically the same".  Query planners may estimate costs
as a function of the average width of a column.  If encrypted character data
has a different average width than plaintext, the query plan may change
accordingly.  But for the most part, I expect this assertion to hold.

 

8.       FYI re anonymized schemas (Section 3, paragraph 3):  This is
obviously valuable in theory, however in 30 years, I have never seen
commercial / govt demand for this, including military contractors, the
federal reserve board, and financial institutions.  

 

9.       Section 3, first processing step:  ". encrypts each constant in the
query.".  SQL has several null-adic functions that return constants e.g.
Oracle's SYSDATE and SQLServer's GETDATE.  I'm not sure of the exact
semantics of these, but they may be evaluated within the DBMS at start of
query or transaction.  It's frequent to see queries whose where clause
requires that a certain date/timestamp column be within a certain interval
of the current date.  The point is that the result of the function wouldn't
be encrypted by the proxy.

 

10.   Section 3, 2nd processing step:  ". issuing and UPDATE query ."   This
is completely fine, but there's another approach.  It could be that the
query requiring onion-keys is exceedingly rare, and that it would be
preferable to keep the current level of encryption most of the time.  In
that case, it might be better to issue a "CTAS" query, creating a temporary
table with the demoted level of encryption.  FYI, in multi-versioning
systems like Oracle and Postgres, CTAS (or select into, or insert into
select from) queries are much faster than UPDATE.

 

11.   HOM description (page 5): "In HOM, the ciphertext is 2048 bits;
however, we can pack.with amortized space overhead of only 2 times."
Question: in a row-oriented DBMS like Oracle or Postgres, does each row have
a value for an integer column?  Is it an index into a 2048 bit block?  Is a
single 2048 bit block somehow shared across rows?  I'm having difficulty
understanding how this works with an existing DBMS.  Another way to ask this
is, what is the SQL type of the column?  Integer?  Char(256)?  Bit(2048)?

 

12.   Last paragraph in section 3.1:  "The DBMS builds indexes of encrypted
columns in the same way as it builds indexes of plaintext data".   I
understand this for OPE or JOIN-OPE.  But if we load with default RND, isn't
an index useless?  Perhaps it really works to build an index on DET.  When
we met, Nickolai said that ordering on DET for purposes of joins and
group-bys would work correctly.  After hours or thought, I think that's
right, but BOY, THAT IS NOT OBVIOUS TO DATABASE PEOPLE LIKE ME.  If the
paper is addressed to 'databasers', this point should be stated explicitly,
maybe twice.  Anyway, rebuilding an index can be very expensive.  So it's
best to let the onion-layering settle down to a steady state before defining
indexes.

 

13.   Fig. 3:  From a performance perspective, for row-oriented DBMSs, it
might be better to create 6 tables, each with two columns than a single
table with 5 columns.  Dragging in unneeded/unused colums is expensive.
Column-oriented DBMSs like Vertica and Paraccel and Sybase should be fine
with the layout in Fig 3.

 

14.   Section 3.2, Write Query Execution:  Variations of INSERT and UPDATE
seem to require encryption within the DBMS

 

a.       Seems like CTAS, Select Into and Insert-into-select-from need some
elaboration here.  When inserting values from one table into another table,
isn't re-encryption required?  If not, why do we need JOIN and JOIN-OPE?
But if encryption is required, it's happening within the DBMS, not the
proxy?

b.       The UPDATE statement may have a nested select expression (on
another table) in the SET clause, and may have an optional FROM clause
(identifying another table, whose columns may be used in the SET clause).
The point is that the SET expressions may take values from other tables.  In
those cases, isn't re-encryption required?

 

15.   Section 3.2, Write Query Execution, 2nd and 3rd paragraphs dealing
with issues involving combination of comparisons and arithemetic operations.
The 2nd paragraph discusses a possible loss of security when allowing
expressions of the form "col_1 + n <relop> <expression>".  It would seem
that this problem can occur in read-only queries (in the WHERE clause) as
well as "write" queries.  But the possible solutions listed in the 3rd
paragraph focus on update.  This type of expression (comparison plus
addition or other calculations) is ubiquitous.  Bringing data back to the AS
for comparison or calculation isn't going to perform well.  A practical
system must allow this type of query to be executed within the DBMS.  In any
event, I didn't follow the solutions offered in the 3rd paragraph.  The
first didn't seem like a solution at all, since it ignored the case of
comparison.  The second solution focused exclusively on the SET clause of an
UPDATE statement  (what about SELECTS with WHERE clauses containing these
expressions), and seems to require moving data out of the DBMS and then back
in.  That works for tiny databases, but not at scale. 

 

16.   Section 3.4, Ciphertext caching.  This is a good idea.  It might make
sense to also keep a cache of "constant-abstracted" queries - parse trees
with the constant values canonicalized - to quickly determine whether the
query needs to be whether and where a query requires transformation.

 

17.   Section 3.5 - see comments above.  First, it would be helpful to a
reader if this section preceded section 3.2/WriteQueryExecution.  Second,
this type of expression occurs with great frequency in applications.
Breaking the query into pieces isn't going to work for most situations.
Maybe there are other ways to detect and prevent attacks - like:

 

a.       Limiting the frequency with which constants can be changed in such
expressions

b.       Allowing annotations to say which columns allow such attacks and
which don't?  For example, its common to do range queries on dates/times.
But knowing the interval between two dates/times might be an acceptable loss
for some applications.

 
