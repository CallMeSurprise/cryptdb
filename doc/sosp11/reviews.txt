
===========================================================================
                           SOSP 2011 Review #53A
                 Updated Tuesday 12 Apr 2011 7:54:24am BST
---------------------------------------------------------------------------
   Paper #53: Confidentiality for Database Applications with Encrypted
              Query Processing
---------------------------------------------------------------------------

                      Overall merit: 4. Accept
                 Reviewer expertise: 1. No familiarity

                         ===== Paper summary =====

The problem addressed in this paper is that of not revealing private
user data that is stored in cloud-based relational databases to nosy
system administrators who have the ability to examine a cloud
computing environment's disks and the content of cloud-based server
machines' memories.  The paper works through the details of executing
SQL queries over encrypted data using a collection of SQL-aware
encryption schemes, thereby enabling data to never have to be
unencrypted while in the database (neither on disk or the DB servers'
memories).  The paper also describes how to tie chain encryption keys
to user passwords, so that a data item can only be decrypted using the
password of one of the users with access to that data.  Thus even if
cloud-based business logic servers are subverted an adversary can only
get to the data of users who logged on during the period that the
adversary controlled the subverted machines.  The performance overhead
of using the proposed encryption-based query schemes is surprisingly
low; for example the performance of TPC-C is reduced by only 27%
compared to running it in regular Postgres.

                        ===== Paper strengths =====

This is a really interesting and important topic for cloud computing
scenarios.  The performance claims are quite surprisingly good and
it's that which makes this paper interesting to the (applied) systems
community, as compared to publishing this result in something like
SigMOD. The paper makes all the encryption-based query schemes used
just intelligible enough to make this paper interesting to the overall
systems community, who are arguably educated laymen regarding both
cryptographic techniques and database query-processing techniques.

                       ===== Paper weaknesses =====

[ ] The paper's results are intriguing, but I'd want to see a lot more
applications examples evaluated before I believe this is generally
useful at practical performance levels.  
[ ] Also, there is no discussion
of whether the levels of security provided by the various encryption
schemes of different strengths are sufficient to satisfy the
requirements of cloud computing customers in practice (some of whose
requirements are based on rigid regulatory requirements).  Thus the
reader can't tell whether the results of this paper take cloud
computing "over the edge" with regards to security or whether they
just represent a (non-trivial) step in the right direction.

                      ===== Comments for author =====

I really liked this paper and, aside from the two areas mentioned
above where I'd like to see additional discussion, I don't have a
whole lot of comments to make:
[  ] * Sec. 2.1: "EncDB reveals only relations between tuples that are
  necessary for the server to execute the query": I strongly suspect
  the average SOSP reader will not have a clear idea of what this
  implies, security-wise.  I realize I'm asking for a tutorial in a
  complicated subject, but anything to indicate how much of a risk
  of practical information exposure we're talking about here would be
  useful.
  My reaction on this subject was reinforced by the sentence a bit
  further down "We believe that these confidentiality properties are
  abut as good as one can provide in practice with current encryption
  technologies."  I believe you, but that gives me no idea of whether
  those properties are good enough to be used in practice.  For
  example, would you be willing to move the bank that has your money
  in it to the cloud, assuming it used EncDB to safeguard your
  personal information, including SSN, credit card numbers, etc.?
  Assuming that you would agree to that, would the various regulatory
  agencies governing banking security agree to it?
[X] * Pg. 6, first paragraph: do you mean "minimum" instead of "maximum"
  in the last sentence?
[X] * Pg. 7, sec. 3.3: It seems like you need to constantly reencrypt
  columns as different queries seek to join different columns.  Your
  evaluation section implies that this is essentially not that big a
  problem in practice, but it would be interesting to understand what
  classes of applications will/won't have problems with this issue.
[X] * Pg. 9, second paragraph of sec. 5: "... (e.g. PRED_POST) ..." --
  where is this in fig. 5?
[  ] * Fig. 6: I didn't understand the NoConflict section of this figure.
[X] * Sec. 7.2.2: "Figure 2" -> "Table 2".

===========================================================================
                           SOSP 2011 Review #53B
                 Updated Sunday 17 Apr 2011 2:31:42pm BST
---------------------------------------------------------------------------
   Paper #53: Confidentiality for Database Applications with Encrypted
              Query Processing
---------------------------------------------------------------------------

                      Overall merit: 5. Strong accept
                 Reviewer expertise: 2. Some familiarity

                         ===== Paper summary =====

Many multi-user on-line systems are backed by a database; a compromise
of this database (or a front-end app server) typically results in the
complete disclosure of all users' information. In this paper the
authors present a scheme which enables a database to operate on
encrypted data: only the end-user has the key, and hence even a total
compromise of the database has limited consequences. The key trick
used is to encrypt different columns in the database with different
schemes depending on whether valid queries will need to e.g. determine
equality, or ordering, or accumulation (addition), etc; storing
multiple encryptions of each datum in an "onion" allows progressively
more liberal encrpytions to be revealed only on demand. The authors
describe their and implementation, and evaluate their performance via
a number of case studies.

                        ===== Paper strengths =====

+ interesting/fun system 
+ potential real-world applications 
+ built practical prototype

                       ===== Paper weaknesses =====

- mostly a combination of previously known techniques

                      ===== Comments for author =====

I really liked this paper - even the 'weakness' I mention above is
actually kinda a strength to me (I like papers which combine a bunch
of point solutions into a coherent whole).

There were a few places where things weren't clear to me: 

[X] - your example of DET on p4 seems curious (i.e. concatenating a 
deterministic suffix to a RND() prefix); it may be that you do this 
in practice to aid with onion peeling, but for clarity it might be 
worth using another example here? 

[X] - the example on p6 you suggest that you would update C2-Onion1 so as
to allow the equality test - does this update overwrite the previous
onion? who has the responsibility of 'remembering' the level of peeling
that has happened for each column?

[X] - p9 introduces 'encddb_active' - is this protected? what exactly is 
its format (e.g. just booleans or... ?) 

[  ] In addition, the security eval (final para section 7.1) is kinda weak... 
Is there something more comprehensive you could do here? 

[ X ] Nits: 

- the example on p8 (figure 4); text says "Bob ... has access to principal 1"; 
this should be '2', right? 

- p12: "Figure 2" -> "Table 2"

===========================================================================
                           SOSP 2011 Review #53C
                Updated Wednesday 27 Apr 2011 7:11:08am BST
---------------------------------------------------------------------------
   Paper #53: Confidentiality for Database Applications with Encrypted
              Query Processing
---------------------------------------------------------------------------

                      Overall merit: 5. Strong accept
                 Reviewer expertise: 2. Some familiarity

                         ===== Paper summary =====

A database proxy that encrypts the entire contents of a database, so that
DBAs can't read database contents, while preserving the ability to run
meaningful queries through pretty clever uses of (mostly-known) encryption.

                        ===== Paper strengths =====

A nice, concrete combination of techniques, well-explained, provides a
semantic I'd have thought much more expensive.

                       ===== Paper weaknesses =====

No one big idea.  Confidentiality may not actually be worth it.

                      ===== Comments for author =====

I very much enjoyed the paper.  Although not a perfect system -- a perfect
system would probably involve some single new insight into computer systems
-- I got enough unexpected pleasure from the paper to rank it very highly.
One insight is simply that I'd have expected this system to perform much
worse than it in fact does.  The generally smooth writing helps a lot.

In the end I don't think one would do this.  The additional security is in
some ways quite limited.  If your application is scaling may not want to
pay the space increase.  But I like the effort and proof-of-concept very
much.

[X] The confidentiality threat model is appropriate, but one might emphasize
more that a DBA or attacker in Threat 2 could still delete the whole
database.

[  ] Section 2 is long winded.  I'd prefer to see related work in Section 2, and
a quick overview of the technical approach, before Section 2 happens.

[X] S2.1: "The DBMS server cannot process queries different from the ones
requested by the application."  Can you adjust this text?  It seems like it
could implement some select, but the result would be meaningless.

[  ] S2.2: The text about threat model 2, both here and earlier & later,
mentions encrypting "different data items" with different keys.  I wrote,
here, "Average salary?", thinking that this would inherently break some
queries you mentioned earlier.  (E.g. an average-salary query would return
the average only among those users logged in at the time!)  So the fact
that only SOME columns are protected for Threat 2 is important.  I think
you should mention this up front.  It might even be a contribution: the
clean integration in your system of per-column keys and per-item keys is
quite nice.

[  ] S2.1: Do you ever mention that "the developer [can] optionally specify the
lowest security level" again?

[X] S3: The query plan is "the same as" for the original query but uses
"modified operators" in some cases: this is not a contradiction because?

OPE: Nice implementation work.

[  ] JOIN: Why does JOIN allow SEARCH privilege?  Is this only used on string
columns?

[  ] S3.2's mechanism for updating Onion 1/2 might require for consistency many
more explicit transactions than DB apps often use.  Those explicit
transactions are a real pain; in PostgreSQL for example an explicit
transaction can fail, forcing the app to retry, which the app might not do.

[X] More nice little tidbits: The debugging trace (S4.1).  The key chaining
cache (S4.2).

[ ] S4.2: Say a principal gains access to an object via public_keys.  Is the
symmetric key eventually added to access_keys?  And if so, then when?  One
might think this would have to happen right away at login.  A classic
home-page query is "show me all the messages I should be able to see".  I
assume that in your system, what will happen is this: The DBMS does a join,
returning all messages; then for each message for which the proxy lacks a
key, the proxy roots around for the key in access_keys/public_keys/etc.
Right?

[ ] Fig4: Might be worth saying that the "PRINC TYPE HAS_ACCESS_TO" syntax's
purpose is to tell the proxy when to add rows to the *_keys tables.  Or am
I wrong?  Might this mean that changing the "PRINC TYPE..." live would
cause expensive recalculation?  More generally one would like to hear more
about schema changes.

[X] S7: You say that "As the number of posts in a forum grows, the amortized
storage overhead decreases..."  I guess posts are different from messages,
which are principals?  Maybe messages are private.

[ ] It is shocking that so much overhead in this encryption-heavy system is due
to your SQL parser.  You should really check this and then thank Moore for
his law.

[  ] Some more microbenchmarks with sensitive fields would be welcome.  TPC-C
with sensitive fields, and thus stresses on the *_keys tables, say.

[  ] Fig11's macrobenchmark of phpBB is only partially interesting -- the system
appears very slow.  Where is the bottleneck in the original MySQL version?

[ X ] Do an old girl a favor and use fewer fonts.  I counted Times Roman,
Computer Modern for math (\usepackage{mathptmx}), Computer Modern Sans for
encryption types (just use capitals or small capitals), Helvetica for
database tables, Lucida Sans Typewriter for SQL statements, and some
thing for Figure 3.  Ugh too many.

[ X ] Also it would be kind to cite "Hot Crap!" as a HotCRP reference.

===========================================================================
                           SOSP 2011 Review #53D
                Updated Saturday 21 May 2011 1:06:30am BST
---------------------------------------------------------------------------
   Paper #53: Confidentiality for Database Applications with Encrypted
              Query Processing
---------------------------------------------------------------------------

                      Overall merit: 3. Weak accept
                 Reviewer expertise: 1. No familiarity

                         ===== Paper summary =====

The paper describes a system for allowing certain kinds of SQL queries
to be performed on data stored in a SQL database while still
encrypted.  The paper defines a partial order of query operators
vs. kind of data that can be revealed by queries that use such an
operator, and then encrypts data within the database using
compositions of encryption techniques.

                        ===== Paper strengths =====

(Caveat: cryptography and security is not really my area, so I would
take more seriously the review comments by those with more expertise
in these areas).

The paper is clearly written, for the most part.

The system seems reasonably easy to use for developers and other users
of the system, while giving some nice properties in preventing certain
kinds of likely attacks.

                       ===== Paper weaknesses =====

It's not clear to me how much novel research is involved in the
system.  The system combines together a bunch of known encryption
techniques.  The onion layering seems useful, but is unlikely to be a
novel contribution of this paper.  The paper keeps encrypted data at
some layer in the onion hierarchy stored in the database, and rewrites
queries to use the encrypted form of the data.  The decrypting data in
the database to more interior onion layers on demand seems like a nice
contribution, but I'm not familiar enough with work in the field to
say if that is a significant contribution of this work.

                      ===== Comments for author =====

A few specific comments:

[X] o 3.1: "The direct implementation of the scheme took ~25 ms per
encryption."  Presumably this is for some particular size of data?

[  ] o 3.1: "Word Search" This paragraph is woefully short of details.
What sorts of queries are supported?  Do you permit wildcards in terms
(e.g. "foo*" or "foo???", or even "*foo*")?  What data is actually
stored in the database?  Is it an inverted index of some kind, or do
you do searches over non-inverted text fields?

[X] o 3.2: "Our idea is to encrypt each data item into an onion".  Yet
later in the paragraph, you say that some values are stored in
multiple onion.  This confused me a great deal on my first reading,
because I got the idea that you only stored data in a single onion per
data item.  Please fix this description (maybe by ending the quoted
sentence with "into one or more onions" instead of "into an onion").

[X] o 3.2: Please spell out "user-defined functions" instead of saying
UDFs (at least the first time that it is used.

[X] o 3.2: "Onion 3 rather than Onion 1 or 2".  What defines onion
numbering?  Do they have any significance?

[  ] o 3.2: Doesn't the onion strategy sometimes make simple queries to be
O(# records in database), rather than O(# records in response)?  This
seems like a drawback that might be worth at least mentioning.

[  ] o 7.2: How would performance compare if you decrypted the data on the
fly, rather than doing a one-time decryption the first time an onion
layer needs to be removed?  I presume it would be bad, but probably
worth having some simple measurements to indicate how bad.

===========================================================================
                           SOSP 2011 Review #53E
                Updated Saturday 21 May 2011 4:35:39pm BST
---------------------------------------------------------------------------
   Paper #53: Confidentiality for Database Applications with Encrypted
              Query Processing
---------------------------------------------------------------------------

                      Overall merit: 2. Weak reject
                 Reviewer expertise: 2. Some familiarity

                         ===== Paper summary =====

This paper presents a database that is secure against
a variety of typical "3-tier" application attacks, i.e.,
a DBA snooping around a hosted database or an adversary
gaining control of an app-server.  It seems that the
main contributions of this work (in crypto and SQL processing
on encrypted data) are both outside the focus of this conference.
I remain curious why this is being submitted to SOSP rather than
a crypto conference or SIGMOD or VLDB.  The systems aspsects
(i.e., architecture) are standard.

                        ===== Paper strengths =====

* Attacks a real problem: database vulnerability.

                       ===== Paper weaknesses =====

* Seems targeted for a different audience (either
crypto or database).

                      ===== Comments for author =====

[ ] In the related work section, the authors tout a feature of EncDB
that it does not require client-side modification or processing.
However, one of the motivations for client-side decryption is that
it avoids precisely the kind of loss given by "threat 2" -- where
an adversary gains control over the app server/proxy.  It seems
obvious to me that I'd rather do decryption on my client than on
an external machine that might have "curious" system administrators.
It would be good to see motivation why the proxy-based decryption
is somehow better than client-side decryption.

[  ] I appreciate how bullet two lists precisely what is not revealed, 
but I would like a more formal statement of the precise semantic
guarantees that EncDB makes.  That is, if I can issue repeated
queries with joins in them, can I infer things about the data?
(It seems that the answer is yes.)

[   ] If an adversary gains control over the AppServer, why can't
said adversary simply issue whatever queries it wants on
behalf of any user whose key is current on the proxy?

[X] What exactly is an anonymized schema?

[  ] It seems that while the security level of the database converges
to the maximum privacy level for every query that has ever been
issued, what this means in practice is that if an application
every issues a query that requires e.g., order-preserving, then
the data remains at that level forever.  If such queries were
rare, then it would seem best to leave data in a more secure 
format and transform it only temporarily.

[  ] Why do you need to implement your own notion of principals
rather than using a DBMS's built-in notion of users?

[X] "As a result, many conferences set up a second server to review the
chair’s papers or use inconvenient out-of-band emails."  It seems
much simpler to not have chairs submit ;-)

===========================================================================
                           SOSP 2011 Review #53F
                 Updated Monday 13 Jun 2011 4:26:34am BST
---------------------------------------------------------------------------
   Paper #53: Confidentiality for Database Applications with Encrypted
              Query Processing
---------------------------------------------------------------------------

                      Overall merit: 4. Accept
                 Reviewer expertise: 4. Expert

                         ===== Paper summary =====

The paper proposes EncDB, a database encryption system for running SQL
queries on encrypted information. EncDB encrypts data in several onion
layers, and decrypts columns based on which functionality is required.

                        ===== Paper strengths =====

Important problem. EncDB is the first system that achieves almost
complete SQL operations on encrypted data. The paper is thorough, well
written overall. The implementation and evaluation are thorough.
The system engineering is impressive.

                       ===== Paper weaknesses =====

[  ] Fundamental limits of database encryption are insufficiently
discussed. How close to optimal security does this approach take us?
The weakest part of the paper is a lack of security analysis capturing
how much secrecy is lost after certain operations. An operator would
want to understand how much secrecy is leaked to a malicious admin
given a certain set of operations. Database integrity is not
considered.

                      ===== Comments for author =====

This paper represents significant progress for achieving database
confidentiality. Several novel concepts are introduced, elegantly
combining a number of existing cryptographic results. 

[  ] Given the space
restrictions, it is understandable that details are missing, however,
it would be nice to understand exactly how private search, etc. was
implemented.

[  ] I would have liked to see a detailed security analysis. Given that a
malicious administrator can violate database integrity, could he use
integrity attacks to derive information about the data by replaying
old information that he wants to decrypt?

[  ] It would be useful to understand the fundamental limits of secrecy for
such database encryption mechanisms. Given that the generality of
queries, it is likely that it is inevitable to leak some amount of
information. Characterizing such data leakage and understanding how
close this paper gets to the theoretical bound would be very useful.

[X] The paper should also contrast the proposed approach against the CLAMP
system, which was published at the Oakland Symposium a few years ago.
To defend against server compromise, CLAMP uses isolation mechanisms
to create a minimal TCB.

[X] To improve the paper, I would suggest do downgrade some claims. For
example, section 2.1 states: "We believe that these confidentiality
properties are about as good as one can provide in practice with
current encryption technologies." This claim is incorrect, because
better secrecy could be achieved if all the data were re-encrypted
after every operation, preventing inferences over time. No doubt, the
paper makes several useful contributions, but I expect followup work
that will provide stronger properties.

===========================================================================
                           SOSP 2011 Review #53G
                 Updated Tuesday 14 Jun 2011 7:56:13am BST
---------------------------------------------------------------------------
   Paper #53: Confidentiality for Database Applications with Encrypted
              Query Processing
---------------------------------------------------------------------------

                      Overall merit: 2. Weak reject
                 Reviewer expertise: 4. Expert

                         ===== Paper summary =====

The paper describes the implementation of a data management system
that works over encrypted data. The main ideas are to (1) use layers of
encryption and to use the level of encryption suitable for the semantics
of the query (2) run queries on encypted data, and (3) annotating the
data with policies for access control.

                        ===== Paper strengths =====

The paper addresses an important practical problem. The proposed solution
is a step forward in practice. The evaluation is well done.

                       ===== Paper weaknesses =====

[  ] The paper both does not discuss its relationship to relevant prior
work. In addition, some of the ideas have already been described in a
paper at CIDR 2011. There is little novelty on concepts in the paper;
the main contribution of the paper is its implementation and performance
analysis.

                      ===== Comments for author =====

[  ] 1.	There is significant overlap with the ideas in the following
paper: Carlo Curino, Evan P. C. Jones, Raluca A. Popa, Nirmesh Malviya,
Eugene Wu, Samuel Madden, Hari Balakrishnan, Nickolai Zeldovich:
Relational Cloud: a Database Service for the cloud. CIDR 2011:
235-240. For example, Figure 2 (SOSP submission) is identical to Figure 2
(CIDR paper); contents of Figures 8 and 9 (SOSP submission) are in Figure
5 (CIDR paper).

[  ] 2.	Why did you invent new mechanisms for associating policies with
data; why can’t you use the existing mechanisms or abstractions of
access control in database systems and just implement them with your
mechanisms using cryptography? There is also related work here that
addresses a very similar problem: Gerome Miklau, Dan Suciu: Controlling
Access to Published Data Using Cryptography. VLDB 2003: 898-909 (and
look at papers that cite this work).

[  ] 3.	How do I revoke privileges? Is it the case that once somebody
had access to some data (and thus possibly got access to some keys) they
will be able to use these keys over and over again to access confidential
data? Would I have to re-encrypt the data in this case?

