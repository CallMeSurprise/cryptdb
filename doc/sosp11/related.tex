% !TEX root = paper.tex

\section{Related Work}
\label{s:related}

{\bf Search and queries over encrypted data.}
Song et al.~\cite{Dawn-Song-Search-2000} and Amanatidis et
al.~\cite{amanatidis-boldyreva-o'neill} describe cryptographic tools
for searching keywords over encrypted data; we use a hybrid of these
schemes in \name{}.
%Goh~\cite{goh03} and Chang \&
%Mitzenmacher~\cite{Chang04privacypreserving} each develop methods for
%searching over pre-defined encrypted indexes, but applying these
%methods to a DBMS would require substantive changes and would be considerably
%slower than existing index structures.  
Bao et al.~\cite{private-query-multi-user-for-searchable} extend these
encrypted search methods to the multi-user case.
% each user has a different secret key used to encrypt data, but any user can
% search for keywords over all the data.
% and the administrator of the ``semi-trusted'' DBMS server is able to
% revoke privileges. 
%Agrawal et al.'s Hippocratic databases~\cite{hippocratic} address the
%problem of preventing unauthorized users from reading confidential
%data by expressing security policies over data items, but do not
%handle the adversary who gains access to the entire DBMS.
Yang et al. run selections with equality predicates over encrypted
data~\cite{Yang-privacy-preserving-queries}.  Evdokimov and Guenther
present methods for the same selections, as well as Cartesian products
and projections~\cite{encrypt-for-secure-outsource}.  Agrawal et
al. develop a statistical encoding that preserves the order of
numerical data in a column~\cite{agrawal2004order}, but it does not
have sound cryptographic properties, unlike the scheme we
use~\cite{boldyreva-ope}. Boneh and Waters show public-key schemes for
comparisons, subset checks, and conjunctions of such queries over
encrypted data~\cite{queriesEncryptionBoneh}, but these are highly
impractical. 

%Amanatidis et al.~\cite{amanatidis-boldyreva-o'neill} propose methods
%for exact searches that do not require scanning the entire database.

%  \name{} uses ... \hb{what?}  To
% support range queries, this scheme reveals all repeating values and
% all common ranges (same prefix values) in the whole database {\em a
%   priori}, which greatly reduces confidentiality.

% key to our security is the dynamically-adjustable encryption based
% on queries: fields that are never used in range queries or
% equalities should remain encrypted with the strongest encryption
% scheme. Finally, they do not support all other queries besides
% equality and prefix-based ranges, and did not build a system.

%These papers all assume a threat model
%similar to threat 1 from \S\ref{s:model}.  

These techniques are undoubtedly important contributions, but even
with {\em all} of these previous techniques, efficient SQL query
processing is unachievable.  Joins are not supported, order checks are
inefficient, and client-side query processing is required; moreover,
implementing many of these techniques would entail unattractive
changes to the innards of the DBMS, and would require users either to
build and maintain indexes on the data at the server or to perform
sequential scans for every selection/search.  Moreover, none of these
schemes was developed in the context of a prototype system.

%approaches are a good first cut at the problem, but are
%incomplete in substantive ways: none of these support the full set of
%SQL queries, providing mostly only equality comparisons; most require
%significant client-side query processing~\cite{xxx}; and most require
%changing the innards of a DBMS~\cite{xxx}.  In addition, some of these
%proposals are inefficient, for example requiring users either to build
%and maintain indexes on the data at the server or else to perform
%sequential scans for every selection/search.  Finally, none of these
%proposals described a working prototype system.  Nevertheless, these
%approaches are useful for confidential text search, and we use a
%similar method for search queries~\cite{amanatidis-boldyreva-o'neill,
%  Dawn-Song-Search-2000}.



%While early proposals attempted to enable SQL processing over
%encrypted data, their privacy mechanisms were heuristic without formal
%guarantees, required a significant rewrite of the DBMS design, relied
%on considerable client-side processing, and did not support a wide
%range of SQL queries.

Some researchers have developed prototype systems for subsets of SQL,
but they provide no confidentiality guarantees, require a significant
DBMS rewrite, and rely on client-side
processing~\cite{sqlOverEncryption,damianiIndex,Ciriani09keepafew};
one proposal requires trusted entities and two non-colluding
untrusted DBMSs~\cite{two-party-computation}.  Hacigumus et al. split
the domain of possible values for each column into partitions, storing
encrypted data~\cite{sqlOverEncryption}. Each partition has as label a
number and each value in a column is replaced with the number of the
partition.
%By grouping elements in partitions in every column, 
However, confidentiality is often compromised because an adversary can
now learn which elements are close together in value and can see the
order of the partitions.  In addition, clients have to filter query
results.  In contrast, our dynamically-adjustable encryption mechanism
only reveals such relations for those columns that are used in a
filter.
%; as we saw
%in \S\ref{s:eval}, such a mechanism successfully keeps sensitive fields
%encrypted with secure encryptions schemes.  
%Moreover, clients have to perform considerable filtering of query
%results because the server runs the queries on partitions rather than
%actual tuples.  
% Damiani et al.~\cite{damianiIndex} require clients to perform part of
% the query processing, Ciriani et al. require that all sensitive data
% be stored on the clients~\cite{Ciriani09keepafew}, and Chow et
% al.~\cite{two-party-computation} require the presence of two
% non-colluding database systems.
% Ozsoyoglu et
% al.~\cite{Ozsoyoglu03anti-tamperdatabases} use UDFs instead of
% changing DBMS internals, but their approach only applies to integers,
% and does not support joins, updates, or inserts.  More
% problematically, they encrypt fields with a
% \textit{distance}-preserving encryption function for which $a-b = E(a)
% - E(b)$, but this approach provides essentially no confidentiality.

%Such scheme is not secure
%because the mere knowledge of one value $a$ for an encryption $E(a)$
%leaks the decryption of all other encrypted values.

% Some papers have addressed the problem of running queries over XML
% documents or databases~\cite{Wang-xml, querying-encrypted-XML}, but
% suffer from several of the drawbacks mentioned above.  \hb{is that
%   true?  actually these two papers are not real systems.}

%Using these partitions, a server
%tries to process as much of a SQL query as possible, leaving the
%remaining processing for the client.



% provide a solution for processing
% range queries over encrypted data.  Each element in a tuple is
% encrypted and hashed to a small number of buckets to improve
% privacy. Range queries can be computed using a B+ tree, but these are
% done by the trusted client that needs to traverse the B+ tree by
% sequentially performing queries at the server. Such work does not
% support joins, aggregates, or string searches.

% TODO: may want to mention work on splitting values over two dbs, requesting
% multiple queries -- these are heuristics and do not help

% Ciriani et. al~\cite{Ciriani09keepafew} propose a new approach to
% confidentiality: replacing data encryption with fragmentation; they
% store a part of the data at the trusted client (e.g. sensitive columns
% or relations between columns) and the rest of the data unencrypted at
% the untrusted server, thus avoiding encryption altogether. However,
% each client (trusted) has to store a potentially large amount of data
% locally and has to perform query processing whenever sensitive data is
% involved in a query. 
%Moreover, as seen in Section \ref{s:eval}, one
%can use encryption at reasonable overheads.

% Chow et al.~\cite{two-party-computation} require the presence of two
% additional parties, a randomizer and a query engine, which are assumed
% not to communicate; moreover, the data is stored at multiple DBMSs
% that do not trust each other. The security of their protocols hinge on
% such security assumptions and on no collusions happening; such a
% setting is not always possible, and solutions without such strong
% trust assumptions may be desirable.


% At a high level, the main contribution of \name over prior work is a
% practical novel approach to guaranteeing privacy in database-backed
% applications.  To our knowledge, \name is the first private system to
% support all the operators used commonly in SQL, perform virtually all
% the query processing on the server, work without modifying the
% internals of existing relational DBMS codebases or client
% applications, and run at a fairly modest performance degradation.

%Related work to \name{} consists of the following solution approaches.

% us. (2) A large part of the query must be resolved on the client side:
% the client finishes filtering selections and joins, as well as finish
% grouping values. This may require a large amount of data sent to the
% client and considerable client-side processing. In \name, queries
% are completely evaluated on server side. (3) Such solution does not
% support some functionality like aggregates and search on strings.  (4)
% Importantly, the design of such a database changes radically the
% design of current databases that have been heavily optimized. (5) Such
% a database system has not been built to prove its practicality.

% \vspace{-0.2cm}

{\bf Untrusted servers.}
SUNDR~\cite{li:sundr} uses cryptography to provide privacy and
integrity in a file system on top of an untrusted file server.  Using
a SUNDR-like system, SPORC~\cite{feldman:sporc} and
Depot~\cite{mahajan:depot} show how to build low-latency applications,
running mostly on the clients, without having to trust a server.
However, existing server-side applications that involve separate
database/storage and application servers cannot be used with these
systems unless they are rewritten into distributed client-side
applications to work with SPORC or Depot; moreover, many applications
are not amenable to such a structure.
In contrast, \name{} provides cryptographic privacy guarantees to
existing database-backed applications.
%On the other hand, because \name{} allows the application server to
%perform any computation, it provides no confidentiality guarantees
%under threat 2 of \S\ref{s:model} for users who were logged in at the
%time of a compromise.

%reveals plaintext data to the
%server for any principals that are currently accessing the
%application, so that the server can perform arbitrary computations on
%the data.


{\bf Software security.}  Many tools help programmers either find or
mitigate mistakes in their code that may lead to vulnerabilities,
including static analysis tools like PQL~\cite{livshits:javasec, martin:pql} and
UrFlow~\cite{chlipala:urflow}, and runtime tools like
Resin~\cite{yip:resin}.
%These tools prevent an adversary
%from exploiting certain types of vulnerabilities by assuming that
%certain components of the system are uncompromised, 
In contrast, \name{} provides privacy guarantees for user data
\textit{even if the adversary gains complete control over the
  application and database servers}.  These tools provide no
guarantees in the face of this threat, but in contrast, \name cannot
provide privacy in the face of vulnerabilities that trick the user's
client machine into issuing unwanted requests (such as cross-site
scripting or cross-site request forgery vulnerabilities in web
applications).  As a result, we anticipate using \name{} together with
these tools to improve overall application security.

Rizvi et al.~\cite{rizvi:fine-grained} and
Chlipala~\cite{chlipala:urflow} specify (and enforce) an application's
security policy over SQL views.  \name{}'s SQL annotations can capture
most of these policies, except for result processing being done in the
policy's view, such as allowing a user to view only aggregates of
certain data.  Unlike prior systems, \name{} enforces SQL-level
policies cryptographically, without relying on compile-time or
run-time permission checks.

% There has been work on designing tools for searching on encrypted data
% and work proposing search on encrypted data for outsourcing DBMS
% privately~\cite{Dawn-Song-Search-2000, Chang04privacypreserving,
%   queriesEncryptionBoneh, private-query-multi-user-for-searchable,
%   amanatidis-boldyreva-o'neill, Yang-privacy-preserving-queries,
%   encrypt-for-secure-outsource}. 
% The work in~\cite{private-query-multi-user-for-searchable} also considers the
% multi-user case.


% recognized that, for a
%privacy-preserving DBMS to be practical at all, one should be willing to reveal
%access patterns needed for the desired class of computation.  They also
%stressed the importance of formally specifying and proving the security
%guarantees of a system to prevent attacks, as we proceed in \name{}.  Their
%work is a cryptographic protocol that allows equality comparisons in a similar
%way to $\DET$ and some limited ranges.

% Amanatidis et al.~\cite{amanatidis-boldyreva-o'neill}, propose encrypting all data with a scheme allowing range queries like OPE: revealing {\em a priori} all repeating values and all common ranges
% (same prefix values) in the whole database (across all columns and rows). This approach leaks significant confidentiality; key to our security is the
% dynamically-adjustable encryption based on queries: fields that are never used
% in range queries or equalities should remain encrypted with the strongest
% encryption scheme. Finally, they do not support all other queries besides
% equality and prefix-based ranges, and did not build a system.

% In addition, the privacy provided by the most secure of these
% previously developed schemes is approximately similar to \name.  For
% example, in Yang et al.'s work~\cite{Yang-privacy-preserving-queries},
% after one query has been made, the server only knows the repetitions
% of the constant in the selection filter, and does not know all the
% repetitions of data in a column as in \name.  Therefore, after one
% equality query, their protocol is more secure. However, after a few
% different queries with the same structure, but different constants,
% \name reveals as much information as their approach. These are
% specific tools and do not enable to server to perform other
% requirements in a DBMS: general range queries, updates of a whole
% column or range of tuples (e.g. increments), aggregates, some cannot
% support joins.

% There is also work allowing the server to build secure
% indexes~\cite{goh03} on encrypted data without having access to the
% data. These approaches require significant changes to the DBMS and would not be
% as portable. Moreover, due to complex cryptographic tools they are
% slower. In our case, the server builds indexes naturally as it would
% on typical (longer) numbers. Ge and Zdonik~\cite{c-store-index} enable
% comparisons and designs indexes for a column store.

%There has been work on processing queries on encrypted
%XML. This work provides useful
%security semantics for XML data, but requires a cumbersome DBMS
%rewrite.
% When applying it to the general
%setting of outsourced databases, there are the following issues: they
%change query processing at the server and requires a rewrite of the
%DBMS\@. 
%Moreover, the results sent to the client are a superset of the true
%result, requiring the client to perform additional post-processing.
%which can sometimes be time consuming and bandwidth wasteful. 
%They also do not discuss updates and inserts.
%, and some are in fact
%search on encrypted data and suffer from similar issues as above when
%applying in our context.

% \paragraph{Theoretical approaches.}
% Theoretical solutions, such as recent work based on fully homomorphic
% encryption~\cite{gentryVerifiable} enables an untrusted party to
% perform any general computation on encrypted data without leaking even
% access patterns to the data. Unfortunately, such approach is
% prohibitively impractical; for example, an author of these schemes
% estimates that a simple string search using fully homomorphic
% encryption is about a trillion times slower than without
% encryption~\cite{trillion}.

% Work in PIR~\cite{pir-survey} allows a user to request a tuple from the database
% without the server learning what tuple was requested. While they provide
% excellent security, such approaches are highly infeasible because, for each
%tuple requested, the server must scan the whole database.
 
{\bf Privacy-preserving aggregates.}
Privacy-preserving data integration, mining, and aggregation
schemes (e.g.~\cite{Kantarcioglu-Clifton-2005, Xiong-2007}) are
useful, but not usable by many applications because they only support
specialized query types and require a rewrite of the DBMS\@.
Differential privacy~\cite{dwork-survey} is complementary
to \name{}; it allows a trusted server to decide what answers to
release and how to obfuscate answers to aggregation queries to avoid
leaking information about any specific record in the database.
% Differential privacy has a different,
%complementary goal from \name{}.
%, but it could be used in concert with \name{}: \name's proxy
%can decide using these tools when and how to release the answer to a
%query.

% and model from \name; in
% fact, one can add differential privacy to the front end in \name tot
% provide to users only privacy-preserving answers.

%% computing over encrypted data

% Maybe mention attribute-based encryption, where Waters et al. use
% algebraic structure of encrypted data to extract statistics.

{\bf Query integrity.}
%Although \name{} does not provide integrity for query results in the
%face of a compromised database server, 
Techniques to ensure integrity for SQL queries can be integrated into
\name{} because \name{} allows relational queries on encrypted data
to be processed just like on plaintext.
%most proposed approaches can be incorporated readily into \name{},
These methods can provide integrity by adding a MAC to each
tuple~\cite{li:sundr,plutus,sirius}, freshness using Merkle or chained
hashes~\cite{plutus,cloudproof,sirius}, and both freshness and
completeness of query results using the approach
in~\cite{queryassurance}.  
%Also, Thompson et al.
In addition, the client can verify the results of aggregation
queries~\cite{Thompson_privacy-preservingcomputation}, and provide
query assurance for most read queries~\cite{sion-assurance}.


%A malicious server can
%affect three aspects of data security: integrity, freshness, and
%completeness. Integrity is solved by adding a MAC to each tuple as
%in~\cite{li:sundr,plutus,sirius}. Freshness has been addressed using
%Merkle hashes or chained hashes~\cite{plutus,cloudproof,sirius} and
%both freshness and completeness of query results are addressed
%in~\cite{queryassurance}.

\nz{Navajo Systems~\cite{navajo}.}

\nz{Relational cloud~\cite{curino:relcloud}.}

